<!DOCTYPE html>
<html lang="en" class="dark">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GeoJSON Editor - Interactive Web Component for Editing GeoJSON Data | @softwarity/geojson-editor</title>
  
  <!-- SEO Meta Tags -->
  <meta name="description" content="A powerful, lightweight Web Component for editing GeoJSON data with syntax highlighting, collapsible nodes, color picker, and MapLibre GL JS integration. Perfect for GIS applications and map editors.">
  <meta name="keywords" content="geojson, editor, web component, custom element, syntax highlighting, json editor, gis, mapping, maplibre, leaflet, openlayers, geospatial, coordinates, feature collection">
  <meta name="author" content="Softwarity">
  <meta name="robots" content="index, follow">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://softwarity.github.io/geojson-editor/">
  <meta property="og:title" content="GeoJSON Editor - Interactive Web Component">
  <meta property="og:description" content="A powerful Web Component for editing GeoJSON data with syntax highlighting, collapsible nodes, and color picker integration.">
  <meta property="og:image" content="https://softwarity.github.io/geojson-editor/og-image.png">
  
  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:url" content="https://softwarity.github.io/geojson-editor/">
  <meta name="twitter:title" content="GeoJSON Editor - Interactive Web Component">
  <meta name="twitter:description" content="A powerful Web Component for editing GeoJSON data with syntax highlighting, collapsible nodes, and color picker integration.">
  
  <!-- Canonical URL -->
  <link rel="canonical" href="https://softwarity.github.io/geojson-editor/">
  
  <!-- Structured Data (JSON-LD) -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "SoftwareApplication",
    "name": "GeoJSON Editor",
    "applicationCategory": "DeveloperApplication",
    "operatingSystem": "Web Browser",
    "description": "A feature-rich GeoJSON editor Web Component with syntax highlighting, collapsible nodes, color picker, and map integration",
    "url": "https://softwarity.github.io/geojson-editor/",
    "author": {
      "@type": "Organization",
      "name": "Softwarity",
      "url": "https://www.softwarity.io/"
    },
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    },
    "license": "https://opensource.org/licenses/MIT"
  }
  </script>
  
  <!-- MapLibre GL JS - Latest version with globe support -->
  <link href="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@latest/dist/maplibre-gl.js"></script>

  <!-- Material Symbols (only icons used, alphabetical order) -->
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200&icon_names=dark_mode,description,language,light_mode,menu_book,palette" rel="stylesheet">

  <style>
    :root {
      --bg-canvas: #0d1117;
      --bg-primary: #161b22;
      --bg-secondary: #21262d;
      --border-default: #30363d;
      --text-primary: #e6edf3;
      --text-secondary: #c9d1d9;
      --text-muted: #8b949e;
      --accent-blue: #58a6ff;
      --accent-green: #238636;
      --accent-green-hover: #2ea043;
      --accent-purple: #a371f7;
      --accent-red: #f85149;
      --font-mono: 'Courier New', monospace;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    /* Color scheme toggle (Tailwind pattern) */
    html.dark { color-scheme: dark; }
    html:not(.dark) { color-scheme: light; }

    /* Material Symbols styling */
    .material-symbols-outlined {
      font-size: 18px;
      vertical-align: middle;
      font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 20;
    }
    .material-symbols-outlined.large {
      font-size: 20px;
      font-variation-settings: 'FILL' 0, 'wght' 400, 'GRAD' 0, 'opsz' 24;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      padding: 2rem;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      min-height: 100vh;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: var(--bg-primary);
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      border: 1px solid var(--border-default);
    }

    h1 { color: var(--text-primary); margin-bottom: 1rem; font-size: 2rem; }

    /* Shared section styles */
    .section-box {
      margin-top: 2rem;
      padding: 1rem;
      background: var(--bg-secondary);
      border-radius: 8px;
      border: 1px solid var(--border-default);
    }
    .section-box h3 { color: var(--text-primary); margin-bottom: 0.5rem; }
    .section-box p { color: var(--text-muted); }

    /* Log container with floating clear button */
    .log-container {
      position: relative;
    }
    .log-container pre {
      padding-bottom: 2.5rem; /* Space for the clear button */
    }
    .btn-clear {
      position: absolute;
      bottom: 0.5rem;
      right: 1.5rem; /* Space for scrollbar */
      padding: 0.2rem 0.4rem;
      font-size: 0.9rem;
      opacity: 0.5;
      line-height: 1;
    }
    .btn-clear:hover {
      opacity: 1;
    }
    .section-box pre {
      background: var(--bg-canvas);
      color: var(--text-secondary);
      padding: 1rem;
      border-radius: 4px;
      overflow: auto;
      font-family: var(--font-mono);
      font-size: 0.85rem;
      border: 1px solid var(--border-default);
    }

    .text-muted { color: var(--text-muted); font-size: 0.85rem; }
    .text-small { font-size: 0.8rem; color: var(--text-muted); margin-left: 0.5rem; }
    .flex-row { display: flex; gap: 0.5rem; }
    .flex-wrap { display: flex; gap: 2rem; flex-wrap: wrap; }

    .description { color: var(--text-muted); margin-bottom: 2rem; line-height: 1.6; }
    .description strong { color: var(--text-secondary); }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      margin-bottom: 2rem;
      padding: 1.5rem;
      background: var(--bg-secondary);
      border-radius: 8px;
      border: 1px solid var(--border-default);
    }

    .controls-section { display: flex; flex-direction: column; gap: 1rem; }
    .controls-section h4 {
      margin: 0;
      color: var(--text-primary);
      font-size: 1rem;
      border-bottom: 2px solid var(--accent-blue);
      padding-bottom: 0.5rem;
    }
    .controls-section > p { color: var(--text-muted); }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1rem;
    }

    .control-group { display: flex; flex-direction: column; gap: 0.5rem; }
    .control-group label { font-weight: 600; color: var(--text-secondary); font-size: 0.9rem; }

    .control-group select,
    .control-group input[type="text"],
    .control-group textarea {
      padding: 0.5rem;
      border: 1px solid var(--border-default);
      border-radius: 4px;
      font-size: 0.9rem;
      font-family: var(--font-mono);
      background: var(--bg-canvas);
      color: var(--text-secondary);
    }
    .control-group select:focus,
    .control-group input[type="text"]:focus,
    .control-group textarea:focus {
      outline: none;
      border-color: var(--accent-blue);
    }

    .checkbox-group { display: flex; align-items: center; gap: 0.5rem; }
    .checkbox-group label { margin: 0; color: var(--text-secondary); }

    .editor-map-row {
      display: flex;
      gap: 1rem;
      margin-top: 2rem;
    }

    .editor-container {
      flex: 1;
      min-width: 0;
      padding: 1rem;
      background: var(--bg-secondary);
      border: 1px solid rgba(88, 166, 255, 0.4);
      border-radius: 8px;
    }

    .editor-label {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 0 0 0.5rem 0;
      color: var(--text-primary);
      font-weight: 600;
    }

    .editor-label .editor-actions {
      display: flex;
      gap: 0.75rem;
      align-items: center;
    }

    .editor-label .editor-actions .editor-checkbox {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      font-size: 0.8rem;
      font-weight: normal;
      cursor: pointer;
    }

    .editor-label .editor-actions button {
      padding: 0.2rem 0.4rem;
      font-size: 0.9rem;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      background: var(--bg-primary);
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s;
      line-height: 1;
    }

    .editor-label .editor-actions button:hover {
      background: var(--accent-color);
      color: white;
      border-color: var(--accent-color);
    }

    .map-container {
      flex: 1;
      min-width: 0;
      padding: 1rem;
      background: var(--bg-secondary);
      border: 1px solid rgba(163, 113, 247, 0.4);
      border-radius: 8px;
    }

    .map-label {
      margin: 0 0 0.5rem 0;
      color: var(--text-primary);
      font-weight: 600;
    }

    #map {
      width: 100%;
      height: 400px;
      border-radius: 4px;
    }

    /* Responsive Design */
    @media (max-width: 900px) {
      body {
        padding: 0;
      }
      .container {
        max-width: 100%;
        border-radius: 0;
        border-left: none;
        border-right: none;
      }
      .editor-map-row {
        flex-direction: column;
      }
      .controls-grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 768px) {
      .container {
        padding: 1rem;
      }
      h1 {
        font-size: 1.5rem;
      }
      .header {
        flex-direction: column;
        align-items: flex-start;
      }
      .controls {
        padding: 1rem;
      }
      .flex-wrap {
        flex-direction: column;
        gap: 1rem;
      }
      .api-toolbar {
        flex-direction: column;
      }
      .api-toolbar button {
        width: 100%;
      }
      #map {
        height: 300px;
      }
      geojson-editor {
        height: 350px !important;
      }
    }

    @media (max-width: 480px) {
      .container {
        padding: 0.75rem;
        max-width: 100%;
        width: 100%;
        margin: 0;
      }
      h1 {
        font-size: 1.25rem;
      }
      .section-box {
        padding: 0.75rem;
        border-radius: 4px;
      }
      .editor-container, .map-container {
        padding: 0.5rem;
        border-radius: 4px;
      }
      .editor-label, .map-label {
        font-size: 0.9rem;
      }
      #map {
        height: 250px;
      }
      geojson-editor {
        height: 300px !important;
      }
      .btn, button {
        padding: 0.4rem 0.75rem;
        font-size: 0.85rem;
      }
    }

    .output pre { max-height: 400px; }
    .output.error { border-color: rgba(248, 81, 73, 0.4); }
    .output.error h3 { color: var(--accent-red); }

    /* Events grid - two columns */
    .events-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
    }
    .event-column h4 {
      color: var(--accent-blue);
      margin-bottom: 0.25rem;
      font-size: 0.9rem;
    }
    .event-column p {
      font-size: 0.8rem;
      margin-bottom: 0.5rem;
    }
    @media (max-width: 768px) {
      .events-grid {
        grid-template-columns: 1fr;
      }
    }

    .code-example pre { line-height: 1.5; margin: 0; }

    /* Base button - neutral/primary style (dark) */
    button, .btn {
      padding: 0.5rem 1rem;
      background: var(--bg-canvas);
      color: var(--text-secondary);
      border: 1px solid var(--border-default);
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
    }
    button:hover, .btn:hover {
      background: var(--border-default);
      color: var(--text-primary);
    }

    /* Action button - green for primary actions (Execute, Apply) */
    .btn-action {
      background: var(--accent-green);
      color: white;
      border-color: var(--accent-green);
    }
    .btn-action:hover {
      background: var(--accent-green-hover);
      border-color: var(--accent-green-hover);
      color: white;
    }

    /* Icon button - compact, for icons only */
    .btn-icon {
      padding: 0.4rem 0.6rem;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    /* Accent button - purple for secondary actions */
    .btn-accent {
      background: var(--accent-purple);
      color: white;
      border-color: var(--accent-purple);
    }
    .btn-accent:hover {
      background: #8b5cf6;
      border-color: #8b5cf6;
      color: white;
    }

    .header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 1rem; flex-wrap: wrap; gap: 1rem; }
    .header h1 { margin: 0; flex: 1; }

    .github-link {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      background: var(--bg-secondary);
      color: var(--text-secondary);
      text-decoration: none;
      border-radius: 6px;
      font-weight: 600;
      font-size: 0.9rem;
      transition: background 0.2s;
      border: 1px solid var(--border-default);
    }
    .github-link:hover { background: var(--border-default); }
    .github-link svg { width: 20px; height: 20px; fill: currentColor; flex-shrink: 0; }
    .github-link .material-symbols-outlined { font-size: 20px; flex-shrink: 0; }

    /* Hide link text on mobile, show only icons */
    @media (max-width: 600px) {
      .header {
        justify-content: flex-end;
      }
      .header > div:first-child {
        width: 100%;
      }
      .github-link {
        padding: 0.5rem;
      }
      .github-link .link-text {
        display: none;
      }
    }

    .info-box {
      background: var(--bg-canvas);
      padding: 0.75rem;
      border-radius: 4px;
      margin-top: 1rem;
      font-size: 0.85rem;
      color: var(--text-muted);
      border-left: 3px solid var(--accent-blue);
    }

    /* Prism.js syntax highlighting - shared tokens */
    .code-example .token.comment, .code-example .token.prolog, .code-example .token.doctype { color: var(--text-muted); }
    .code-example .token.punctuation, .code-example .token.operator, .code-example .token.entity, .code-example .token.url, .code-example .token.variable { color: var(--text-secondary); }
    .code-example .token.property, .code-example .token.tag, .code-example .token.boolean, .code-example .token.number, .code-example .token.constant, .code-example .token.symbol { color: #79c0ff; }
    .code-example .token.selector, .code-example .token.attr-name, .code-example .token.string, .code-example .token.char, .code-example .token.builtin { color: #a5d6ff; }
    .code-example .token.atrule, .code-example .token.attr-value, .code-example .token.keyword { color: #ff7b72; }
    .code-example .token.function { color: #d2a8ff; }
    .code-example .token.regex, .code-example .token.important { color: #ffa657; }

    /* JSON syntax highlighting for event log */
    .json-highlight .token.punctuation { color: var(--text-secondary); }
    .json-highlight .token.property { color: #79c0ff; }
    .json-highlight .token.string { color: #a5d6ff; }
    .json-highlight .token.number { color: #79c0ff; }
    .json-highlight .token.boolean { color: #ff7b72; }
    .json-highlight .token.null { color: #ff7b72; }
    .json-highlight .token.operator { color: var(--text-secondary); }

    /* Modal */
    .modal { position: fixed; inset: 0; z-index: 1000; display: flex; align-items: center; justify-content: center; }
    .modal-backdrop { position: absolute; inset: 0; background: rgba(0, 0, 0, 0.7); }
    .modal-content {
      position: relative;
      background: var(--bg-primary);
      border-radius: 12px;
      width: 90%;
      max-width: 700px;
      max-height: 90vh;
      overflow: hidden;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      border: 1px solid var(--border-default);
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border-default);
      background: var(--bg-secondary);
    }
    .modal-header h3 { margin: 0; color: var(--text-primary); }
    .modal-close {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-muted);
      padding: 0;
      line-height: 1;
    }
    .modal-close:hover { color: var(--text-primary); }
    .modal-body { padding: 1.5rem; overflow-y: auto; max-height: calc(90vh - 60px); }
    .modal-body p { color: var(--text-muted); }
    .theme-actions { display: flex; gap: 0.5rem; margin-top: 1rem; flex-wrap: wrap; justify-content: flex-end; }

    #themeTextarea {
      width: 100%;
      font-family: var(--font-mono);
      font-size: 0.85rem;
      padding: 1rem;
      border: 1px solid var(--border-default);
      border-radius: 4px;
      resize: vertical;
      background: var(--bg-canvas);
      color: var(--text-secondary);
    }
    #themeTextarea:focus { outline: none; border-color: var(--accent-blue); }

    /* API Toolbar */
    .api-toolbar {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin-top: 1rem;
      padding: 1rem;
      background: var(--bg-secondary);
      border-radius: 8px;
      border: 1px solid var(--border-default);
    }
    .api-toolbar h4 {
      width: 100%;
      margin: 0 0 0.5rem 0;
      color: var(--text-primary);
      font-size: 0.9rem;
      border-bottom: 2px solid var(--accent-purple);
      padding-bottom: 0.5rem;
    }
    .api-btn {
      padding: 0.5rem 1rem;
      background: var(--accent-purple);
      color: white;
      border: 1px solid var(--accent-purple);
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
      font-size: 0.85rem;
      transition: all 0.2s;
    }
    .api-btn:hover {
      background: #8b5cf6;
      border-color: #8b5cf6;
      box-shadow: 0 2px 8px rgba(139, 92, 246, 0.4);
    }
    .api-btn.danger {
      background: var(--accent-red);
      border-color: var(--accent-red);
    }
    .api-btn.danger:hover {
      background: #dc2626;
      border-color: #dc2626;
      box-shadow: 0 2px 8px rgba(220, 38, 38, 0.4);
    }

    /* API Modal */
    .api-modal-body { padding: 1.5rem; }
    .api-modal-body label {
      display: block;
      margin-bottom: 0.5rem;
      color: var(--text-secondary);
      font-weight: 600;
    }
    .api-modal-body textarea {
      width: 100%;
      min-height: 200px;
      font-family: var(--font-mono);
      font-size: 0.85rem;
      padding: 1rem;
      border: 1px solid var(--border-default);
      border-radius: 4px;
      resize: vertical;
      background: var(--bg-canvas);
      color: var(--text-secondary);
    }
    .api-modal-body textarea:focus { outline: none; border-color: var(--accent-blue); }
    .api-modal-body input[type="number"] {
      width: 100%;
      padding: 0.75rem;
      font-family: var(--font-mono);
      font-size: 1rem;
      border: 1px solid var(--border-default);
      border-radius: 4px;
      background: var(--bg-canvas);
      color: var(--text-secondary);
    }
    .api-modal-body input[type="number"]:focus { outline: none; border-color: var(--accent-blue); }
    .api-modal-body select {
      width: 100%;
      padding: 0.75rem;
      font-family: var(--font-mono);
      font-size: 0.9rem;
      border: 1px solid var(--border-default);
      border-radius: 4px;
      background: var(--bg-canvas);
      color: var(--text-secondary);
      cursor: pointer;
    }
    .api-modal-body select:focus { outline: none; border-color: var(--accent-blue); }
    .api-code-preview {
      max-height: 300px;
      overflow: auto;
      border: 1px solid var(--border-default);
      border-radius: 4px;
      background: var(--bg-canvas);
    }
    .api-code-preview pre {
      margin: 0;
      padding: 1rem;
      font-size: 0.85rem;
      line-height: 1.5;
    }
    .api-code-preview code {
      font-family: var(--font-mono);
    }
    .api-modal-actions {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
      justify-content: flex-end;
    }
    .api-modal-actions button { min-width: 100px; }
    .api-modal-error {
      margin-top: 0.5rem;
      padding: 0.5rem;
      background: rgba(248, 81, 73, 0.1);
      border: 1px solid var(--accent-red);
      border-radius: 4px;
      color: var(--accent-red);
      font-size: 0.85rem;
    }
    .form-group { margin-bottom: 1rem; }
    .form-group:last-of-type { margin-bottom: 0; }

    /* Collapsed checkboxes */
    .collapsed-checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      padding: 0.5rem;
      background: var(--bg-canvas);
      border: 1px solid var(--border-default);
      border-radius: 4px;
    }
    .collapsed-checkboxes label {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      font-size: 0.85rem;
      cursor: pointer;
      margin: 0;
    }
    .collapsed-checkboxes input[type="checkbox"] {
      cursor: pointer;
    }

    /* Collapsed default hint */
    .collapsed-default-hint {
      font-weight: normal;
      font-size: 0.8rem;
      color: var(--text-muted);
      font-style: italic;
    }

    /* API call preview */
    .api-call-preview {
      background: var(--bg-canvas);
      border: 1px solid var(--border-default);
      border-radius: 4px;
      overflow-x: auto;
    }
    .api-call-preview pre {
      margin: 0;
      padding: 0.75rem;
      font-size: 0.85rem;
      line-height: 1.5;
    }
    .api-call-preview code {
      font-family: var(--font-mono);
      white-space: pre;
    }

    /* Toast animations */
    @keyframes toastFadeIn {
      from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
      to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
    }
    @keyframes toastFadeOut {
      from { opacity: 1; transform: translate(-50%, -50%) scale(1); }
      to { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
    }

    /* Footer */
    .footer {
      margin-top: 2rem;
      padding: 1rem 1.5rem 0;
      text-align: center;
      border-top: 1px solid var(--border-default);
    }
    .footer a {
      color: var(--text-muted);
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      transition: opacity 0.2s;
    }
    .footer a:hover {
      opacity: 0.8;
    }
    .footer img {
      width: 20px;
      height: 20px;
    }
  </style>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-json.min.js"></script>
</head>
<body>
  <div class="container">
    <div class="header">
      <div style="display: flex; align-items: center; gap: 1rem;">
        <a href="https://www.softwarity.io/" target="_blank" rel="noopener noreferrer" title="Softwarity">
          <img src="https://www.softwarity.io/img/softwarity.svg" alt="Softwarity" style="height: 40px;">
        </a>
        <div>
          <h1 style="margin-bottom: 0.5rem;">@softwarity/geojson-editor</h1>
          <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
            <a href="https://www.npmjs.com/package/@softwarity/geojson-editor" target="_blank" rel="noopener">
              <img src="https://img.shields.io/npm/v/@softwarity/geojson-editor?color=blue&label=npm" alt="npm version">
            </a>
            <a href="https://bundlephobia.com/package/@softwarity/geojson-editor" target="_blank" rel="noopener">
              <img src="https://img.shields.io/bundlephobia/minzip/@softwarity/geojson-editor?label=size" alt="bundle size">
            </a>
            <a href="https://github.com/softwarity/geojson-editor/blob/main/LICENSE" target="_blank" rel="noopener">
              <img src="https://img.shields.io/badge/license-MIT-blue" alt="license">
            </a>
            <a href="https://codecov.io/gh/softwarity/geojson-editor" target="_blank" rel="noopener">
              <img src="https://codecov.io/gh/softwarity/geojson-editor/graph/badge.svg" alt="codecov">
            </a>
          </div>
        </div>
      </div>
      <div style="display: flex; gap: 1rem; align-items: center;">
        <a href="https://github.com/softwarity/geojson-editor#readme" target="_blank" rel="noopener noreferrer" class="github-link">
          <span class="material-symbols-outlined">menu_book</span>
          <span class="link-text">Documentation</span>
        </a>
        <a href="https://github.com/softwarity/geojson-editor/blob/main/RELEASE_NOTES.md" target="_blank" rel="noopener noreferrer" class="github-link">
          <span class="material-symbols-outlined">description</span>
          <span class="link-text">Release Notes</span>
        </a>
        <a href="https://github.com/softwarity/geojson-editor" target="_blank" rel="noopener noreferrer" class="github-link">
          <svg viewBox="0 0 16 16" width="20" height="20" aria-hidden="true">
            <path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
          </svg>
          <span class="link-text">GitHub</span>
        </a>
        <a href="https://www.softwarity.io/" target="_blank" rel="noopener noreferrer" class="github-link">
          <span class="material-symbols-outlined">language</span>
          <span class="link-text">Softwarity</span>
        </a>
      </div>
    </div>
    <div class="description">
      A lightweight Web Component for editing GeoJSON — with built-in validation, contextual type highlighting, auto-collapse coordinates, and feature visibility toggle (eye icon to hide/show features from events).
      <span style="color: var(--text-muted);">No Monaco (2.5 MB), no CodeMirror (150 KB), just what you need for GeoJSON.</span>
    </div>

    <div class="controls">
      <div class="controls-section">
        <h4>Theme</h4>
        <div class="controls-grid">
          <div class="control-group">
            <label for="themePresetMainSelect">Theme Preset</label>
            <div style="display: flex; gap: 0.5rem;">
              <select id="themePresetMainSelect" style="flex: 1;">
                <option value="" selected>Default (IntelliJ)</option>
                <option value="vscode">VS Code</option>
                <option value="github">GitHub</option>
                <option value="monokai">Monokai</option>
                <option value="solarized">Solarized</option>
              </select>
              <button class="btn-icon btn-accent" onclick="openThemeModal()" title="View theme CSS"><span class="material-symbols-outlined">palette</span></button>
              <button class="btn-icon" id="colorSchemeToggle" onclick="toggleColorScheme()" title="Toggle light/dark mode"><span class="material-symbols-outlined">light_mode</span></button>
            </div>
          </div>
        </div>
      </div>

      <div class="controls-section">
        <h4>Editor Options</h4>
        <div class="control-group" style="margin-bottom: 1rem;">
          <label for="placeholderInput">Placeholder Text (supports multi-line)</label>
          <textarea id="placeholderInput" rows="4">Enter GeoJSON features here...

Example:
{ "type": "Feature", "geometry": {...} }</textarea>
          <small style="color: #666; font-size: 0.85rem;">Shown when editor is empty</small>
        </div>
        <div class="info-box">
          <strong>Note:</strong> Edit features directly (comma-separated). The component wraps them in a FeatureCollection and emits the complete structure on change events.
        </div>
      </div>
    </div>

    <div class="editor-map-row">
      <div class="editor-container">
        <div class="editor-label">
          <span>GeoJSON Editor</span>
          <div class="editor-actions">
            <label class="editor-checkbox">
              <input type="checkbox" id="readonlyToggle" onchange="toggleReadonly()">
              <span>Readonly</span>
            </label>
            <label class="editor-checkbox" title="Enable Ctrl+I to add features via prompt">
              <input type="checkbox" id="internalAddToggle" onchange="toggleInternalAdd()">
              <span>Ctrl+I Add</span>
            </label>
            <button id="resetBtn" onclick="resetEditor()" title="Reset to original sample">↺</button>
          </div>
        </div>
        <geojson-editor id="editor"></geojson-editor>
      </div>
      <div class="map-container">
        <div class="map-label">MapLibre Preview</div>
        <div id="map"></div>
      </div>
    </div>

    <!-- API Toolbar -->
    <div class="api-toolbar">
      <h4>Features API</h4>
      <button class="api-btn" onclick="openApiModal('set')">set()</button>
      <button class="api-btn" onclick="openApiModal('add')">add()</button>
      <button class="api-btn" onclick="openApiModal('insertAt')">insertAt()</button>
      <button class="api-btn" onclick="openApiModal('removeAt')">removeAt()</button>
      <button class="api-btn danger" onclick="apiRemoveAll()">removeAll()</button>
      <button class="api-btn" onclick="apiEmit()">emit()</button>
    </div>

    <div class="section-box output">
      <h3>Events:</h3>
      <div class="events-grid">
        <div class="event-column">
          <h4>change</h4>
          <p>FeatureCollection (all visible features)</p>
          <div class="log-container">
            <pre id="eventLog" class="json-highlight">Waiting for change events...</pre>
            <button class="btn-clear" onclick="clearEventLog()" title="Clear">✕</button>
          </div>
        </div>
        <div class="event-column">
          <h4>current-feature</h4>
          <p>Feature at cursor (or null)</p>
          <div class="log-container">
            <pre id="currentFeatureLog" class="json-highlight">null</pre>
          </div>
        </div>
      </div>
    </div>

    <div class="section-box output error">
      <h3>Error Events:</h3>
      <p>
        When JSON is invalid, the component emits <code>error</code> events with:
        <strong>timestamp</strong>,
        <strong>error</strong> (error message),
        <strong>content</strong> (editor content for debugging)
      </p>
      <div class="log-container">
        <pre id="errorLog">No errors</pre>
        <button class="btn-clear" onclick="clearErrorLog()" title="Clear">✕</button>
      </div>
    </div>

    <div class="section-box code-example">
      <h3>HTML Code:</h3>
      <p>
        Copy this code to use the component in your own page (updates automatically with your settings)
      </p>
      <pre id="htmlCode"></pre>
    </div>

    <!-- Footer -->
    <footer class="footer">
      <a href="https://www.softwarity.io/" target="_blank" rel="noopener noreferrer">
        <img src="https://www.softwarity.io/img/softwarity.svg" alt="Softwarity logo">
        Made by Softwarity
      </a>
    </footer>
  </div>

  <!-- Theme CSS Viewer Modal -->
  <div id="themeModal" class="modal" style="display: none;">
    <div class="modal-backdrop" onclick="closeThemeModal()"></div>
    <div class="modal-content">
      <div class="modal-header">
        <h3 style="display: flex; align-items: center; gap: 0.5rem;"><span class="material-symbols-outlined large">palette</span> Theme CSS</h3>
        <button class="modal-close" onclick="closeThemeModal()">×</button>
      </div>
      <div class="modal-body">
        <p style="color: #666; font-size: 0.85rem; margin-bottom: 1rem;">
          Themes are CSS files using <code>light-dark()</code> for automatic dark/light switching.<br>
          Edit the CSS below and click "Apply" to preview, or "Copy" to use in your project.
        </p>
        <textarea id="themeTextarea" rows="20" spellcheck="false"></textarea>
        <div class="theme-actions">
          <button onclick="resetTheme()">Reset</button>
          <button onclick="copyTheme()">Copy CSS</button>
          <button class="btn-action" onclick="applyTheme()">Apply</button>
        </div>
      </div>
    </div>
  </div>

  <!-- API Modal -->
  <div id="apiModal" class="modal" style="display: none;">
    <div class="modal-backdrop" onclick="closeApiModal()"></div>
    <div class="modal-content" style="max-width: 600px;">
      <div class="modal-header">
        <h3 id="apiModalTitle">API Method</h3>
        <button class="modal-close" onclick="closeApiModal()">×</button>
      </div>
      <div class="modal-body api-modal-body">
        <!-- set() form -->
        <div id="apiFormSet" style="display: none;">
          <div class="form-group">
            <label for="apiSetFormat">Input Format</label>
            <select id="apiSetFormat" onchange="loadApiSample('set'); updateApiCallPreview('set')">
              <option value="feature-collection">FeatureCollection</option>
              <option value="features">Feature[]</option>
              <option value="feature">Feature</option>
            </select>
          </div>
          <div class="form-group">
            <label>Collapsed Attributes <span class="collapsed-default-hint" id="apiSetDefaultHint">(default: coordinates)</span></label>
            <div class="collapsed-checkboxes">
              <label><input type="checkbox" value="$root" onchange="updateApiCallPreview('set')"> $root</label>
              <label><input type="checkbox" value="coordinates" onchange="updateApiCallPreview('set')"> coordinates</label>
              <label><input type="checkbox" value="geometry" onchange="updateApiCallPreview('set')"> geometry</label>
              <label><input type="checkbox" value="properties" onchange="updateApiCallPreview('set')"> properties</label>
            </div>
          </div>
          <div class="form-group">
            <label>API Call</label>
            <div id="apiSetCallPreview" class="api-call-preview"><pre><code class="language-javascript"></code></pre></div>
          </div>
          <div class="form-group">
            <label>Data Preview (read-only)</label>
            <div id="apiSetPreview" class="api-code-preview json-highlight">
              <pre><code></code></pre>
            </div>
          </div>
        </div>

        <!-- add() form -->
        <div id="apiFormAdd" style="display: none;">
          <div class="form-group">
            <label for="apiAddFormat">Input Format</label>
            <select id="apiAddFormat" onchange="loadApiSample('add'); updateApiCallPreview('add')">
              <option value="feature-collection">FeatureCollection</option>
              <option value="features">Feature[]</option>
              <option value="feature">Feature</option>
            </select>
          </div>
          <div class="form-group">
            <label>Collapsed Attributes <span class="collapsed-default-hint" id="apiAddDefaultHint">(default: coordinates)</span></label>
            <div class="collapsed-checkboxes">
              <label><input type="checkbox" value="$root" onchange="updateApiCallPreview('add')"> $root</label>
              <label><input type="checkbox" value="coordinates" onchange="updateApiCallPreview('add')"> coordinates</label>
              <label><input type="checkbox" value="geometry" onchange="updateApiCallPreview('add')"> geometry</label>
              <label><input type="checkbox" value="properties" onchange="updateApiCallPreview('add')"> properties</label>
            </div>
          </div>
          <div class="form-group">
            <label>API Call</label>
            <div id="apiAddCallPreview" class="api-call-preview"><pre><code class="language-javascript"></code></pre></div>
          </div>
          <div class="form-group">
            <label>Data Preview (read-only)</label>
            <div id="apiAddPreview" class="api-code-preview json-highlight">
              <pre><code></code></pre>
            </div>
          </div>
        </div>

        <!-- insertAt() form -->
        <div id="apiFormInsertAt" style="display: none;">
          <div class="form-group">
            <label for="apiInsertAtFormat">Input Format</label>
            <select id="apiInsertAtFormat" onchange="loadApiSample('insertAt'); updateApiCallPreview('insertAt')">
              <option value="feature-collection">FeatureCollection</option>
              <option value="features">Feature[]</option>
              <option value="feature">Feature</option>
            </select>
          </div>
          <div class="form-group">
            <label for="apiInsertAtIndex">Index (negative = from end)</label>
            <input type="number" id="apiInsertAtIndex" value="0" oninput="updateApiCallPreview('insertAt')" />
          </div>
          <div class="form-group">
            <label>Collapsed Attributes <span class="collapsed-default-hint" id="apiInsertAtDefaultHint">(default: coordinates)</span></label>
            <div class="collapsed-checkboxes">
              <label><input type="checkbox" value="$root" onchange="updateApiCallPreview('insertAt')"> $root</label>
              <label><input type="checkbox" value="coordinates" onchange="updateApiCallPreview('insertAt')"> coordinates</label>
              <label><input type="checkbox" value="geometry" onchange="updateApiCallPreview('insertAt')"> geometry</label>
              <label><input type="checkbox" value="properties" onchange="updateApiCallPreview('insertAt')"> properties</label>
            </div>
          </div>
          <div class="form-group">
            <label>API Call</label>
            <div id="apiInsertAtCallPreview" class="api-call-preview"><pre><code class="language-javascript"></code></pre></div>
          </div>
          <div class="form-group">
            <label>Data Preview (read-only)</label>
            <div id="apiInsertAtPreview" class="api-code-preview json-highlight">
              <pre><code></code></pre>
            </div>
          </div>
        </div>

        <!-- removeAt() form -->
        <div id="apiFormRemoveAt" style="display: none;">
          <div class="form-group">
            <label for="apiRemoveAtIndex">Index (negative = from end, e.g. -1 = last)</label>
            <input type="number" id="apiRemoveAtIndex" value="0" />
          </div>
        </div>

        <div id="apiModalError" class="api-modal-error" style="display: none;"></div>

        <div class="api-modal-actions">
          <button onclick="closeApiModal()">Cancel</button>
          <button class="btn-action" onclick="executeApiMethod()">Execute</button>
        </div>
      </div>
    </div>
  </div>


  <script>
    const editor = document.getElementById('editor');
    const eventLog = document.getElementById('eventLog');
    const errorLog = document.getElementById('errorLog');
    const placeholderInput = document.getElementById('placeholderInput');
    const themeModal = document.getElementById('themeModal');
    const themeTextarea = document.getElementById('themeTextarea');
    const themePresetMainSelect = document.getElementById('themePresetMainSelect');

    // Initialize MapLibre map with globe projection
    const map = new maplibregl.Map({
      container: 'map',
      style: 'https://demotiles.maplibre.org/style.json',
      center: [29.8, -3.4],
      zoom: 2
    });

    // Add navigation controls
    map.addControl(new maplibregl.NavigationControl(), 'top-right');

    // Store pending GeoJSON if map not ready yet
    let pendingGeojson = null;

    // Setup map when loaded
    map.on('load', () => {
      // Set globe projection for 3D Earth view
      map.setProjection({ type: 'globe' });

      // Add GeoJSON source
      map.addSource('geojson-data', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });

      // Add vertices source (for features with marker: true)
      map.addSource('vertices-data', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });

      // Polygon fill layer
      map.addLayer({
        id: 'geojson-fill',
        type: 'fill',
        source: 'geojson-data',
        filter: ['==', '$type', 'Polygon'],
        paint: {
          'fill-color': ['coalesce', ['get', 'fill-color'], '#58a6ff'],
          'fill-opacity': ['coalesce', ['get', 'fill-opacity'], 0.4]
        }
      });

      // Polygon outline layer
      map.addLayer({
        id: 'geojson-outline',
        type: 'line',
        source: 'geojson-data',
        filter: ['==', '$type', 'Polygon'],
        paint: {
          'line-color': ['coalesce', ['get', 'stroke-color'], '#58a6ff'],
          'line-width': ['coalesce', ['get', 'stroke-width'], 2]
        }
      });

      // LineString layer
      map.addLayer({
        id: 'geojson-line',
        type: 'line',
        source: 'geojson-data',
        filter: ['==', '$type', 'LineString'],
        paint: {
          'line-color': ['coalesce', ['get', 'stroke-color'], '#a371f7'],
          'line-width': ['coalesce', ['get', 'stroke-width'], 3]
        }
      });

      // Point layer
      map.addLayer({
        id: 'geojson-point',
        type: 'circle',
        source: 'geojson-data',
        filter: ['==', '$type', 'Point'],
        paint: {
          'circle-radius': 8,
          'circle-color': ['coalesce', ['get', 'fill-color'], '#f85149'],
          'circle-stroke-color': ['coalesce', ['get', 'stroke-color'], '#ffffff'],
          'circle-stroke-width': ['coalesce', ['get', 'stroke-width'], 2]
        }
      });

      // Label layer for features with 'label' property
      map.addLayer({
        id: 'geojson-labels',
        type: 'symbol',
        source: 'geojson-data',
        filter: ['has', 'label'],
        layout: {
          'text-field': ['get', 'label'],
          'text-size': ['coalesce', ['get', 'label-size'], 14],
          'text-anchor': 'center',
          'text-allow-overlap': false
        },
        paint: {
          'text-color': ['coalesce', ['get', 'label-color'], '#ffffff'],
          'text-halo-color': ['coalesce', ['get', 'label-halo-color'], '#000000'],
          'text-halo-width': ['coalesce', ['get', 'label-halo-width'], 1.5]
        }
      });

      // Vertices layer (for LineString/Polygon with marker: true)
      map.addLayer({
        id: 'geojson-vertices',
        type: 'circle',
        source: 'vertices-data',
        paint: {
          'circle-radius': ['coalesce', ['get', 'marker-width'], 5],
          'circle-color': ['coalesce', ['get', 'marker-color'], '#ff6b35'],
          'circle-opacity': ['coalesce', ['get', 'marker-opacity'], 0.9],
          'circle-stroke-width': 1,
          'circle-stroke-color': '#ffffff'
        }
      });

      // Add highlight source for current-feature
      map.addSource('highlight-data', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });

      // Highlight layers - rendered on top with blinking animation
      // Polygon fill highlight
      map.addLayer({
        id: 'highlight-fill',
        type: 'fill',
        source: 'highlight-data',
        filter: ['==', '$type', 'Polygon'],
        paint: {
          'fill-color': ['coalesce', ['get', 'fill-color'], '#ff6b35'],
          'fill-opacity': 0.3
        }
      });

      // Polygon/LineString outline highlight (wider stroke)
      map.addLayer({
        id: 'highlight-line',
        type: 'line',
        source: 'highlight-data',
        filter: ['any', ['==', '$type', 'Polygon'], ['==', '$type', 'LineString']],
        paint: {
          'line-color': ['coalesce', ['get', 'stroke-color'], '#ff6b35'],
          'line-width': ['+', ['coalesce', ['get', 'stroke-width'], 2], 2]
        }
      });

      // Point highlight (larger circle)
      map.addLayer({
        id: 'highlight-point',
        type: 'circle',
        source: 'highlight-data',
        filter: ['==', '$type', 'Point'],
        paint: {
          'circle-radius': 12,
          'circle-color': ['coalesce', ['get', 'fill-color'], '#ff6b35'],
          'circle-stroke-color': '#ffffff',
          'circle-stroke-width': 3
        }
      });

      // Add animated icons source
      map.addSource('animated-icons-data', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });

      // Add animated icons layer
      map.addLayer({
        id: 'animated-icons',
        type: 'symbol',
        source: 'animated-icons-data',
        layout: {
          'icon-image': ['get', 'icon-id'],
          'icon-size': ['/', ['coalesce', ['get', 'icon-size'], 24], 24],
          'icon-rotate': ['get', 'icon-rotate'],
          'icon-rotation-alignment': 'map',
          'icon-allow-overlap': true
        }
      });

      // Apply pending GeoJSON if data was loaded before map was ready
      if (pendingGeojson) {
        updateMap(pendingGeojson);
        pendingGeojson = null;
      }
    });

    // =====================================================
    // ANIMATED ICONS SYSTEM
    // =====================================================
    
    // Store for active animations
    const activeAnimations = new Map();
    let animationFrameId = null;

    // Available icon SVGs (pointing UP by default)
    const ICON_SVGS = {
      airplane: 'M280-80v-100l120-84v-144L80-280v-120l320-224v-176q0-33 23.5-56.5T480-880q33 0 56.5 23.5T560-800v176l320 224v120L560-408v144l120 84v100l-200-60-200 60Z'
    };

    // Create a colored icon and add it to the map
    function getOrCreateIcon(iconName, color, size) {
      const iconId = `${iconName}-${color.replace('#', '')}`;
      
      if (!map.hasImage(iconId)) {
        const svgPath = ICON_SVGS[iconName];
        if (!svgPath) return null;
        
        // Create SVG with the specified color
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 -960 960 960"><path d="${svgPath}" fill="${color}"/></svg>`;
        
        // Create image from SVG
        const img = new Image(size, size);
        img.onload = () => {
          if (!map.hasImage(iconId)) {
            map.addImage(iconId, img);
          }
        };
        img.src = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svg);
      }
      
      return iconId;
    }

    // Calculate bearing between two points
    function calculateBearing(start, end) {
      const startLat = start[1] * Math.PI / 180;
      const startLng = start[0] * Math.PI / 180;
      const endLat = end[1] * Math.PI / 180;
      const endLng = end[0] * Math.PI / 180;
      
      const dLng = endLng - startLng;
      
      const x = Math.sin(dLng) * Math.cos(endLat);
      const y = Math.cos(startLat) * Math.sin(endLat) - Math.sin(startLat) * Math.cos(endLat) * Math.cos(dLng);
      
      let bearing = Math.atan2(x, y) * 180 / Math.PI;
      return (bearing + 360) % 360;
    }

    // Calculate distance between two points (in km)
    function calculateDistance(start, end) {
      const R = 6371; // Earth radius in km
      const dLat = (end[1] - start[1]) * Math.PI / 180;
      const dLng = (end[0] - start[0]) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(start[1] * Math.PI / 180) * Math.cos(end[1] * Math.PI / 180) *
                Math.sin(dLng/2) * Math.sin(dLng/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    // Interpolate position along a line at given fraction (0-1)
    function interpolateAlongLine(coordinates, fraction) {
      if (coordinates.length < 2) return coordinates[0];
      
      // Calculate total length
      let totalLength = 0;
      const segmentLengths = [];
      for (let i = 0; i < coordinates.length - 1; i++) {
        const len = calculateDistance(coordinates[i], coordinates[i + 1]);
        segmentLengths.push(len);
        totalLength += len;
      }
      
      const targetDistance = fraction * totalLength;
      let accumulatedDistance = 0;
      
      for (let i = 0; i < segmentLengths.length; i++) {
        if (accumulatedDistance + segmentLengths[i] >= targetDistance) {
          // We're in this segment
          const segmentFraction = (targetDistance - accumulatedDistance) / segmentLengths[i];
          const start = coordinates[i];
          const end = coordinates[i + 1];
          
          // Great circle interpolation for accuracy on globe
          const lng = start[0] + (end[0] - start[0]) * segmentFraction;
          const lat = start[1] + (end[1] - start[1]) * segmentFraction;
          
          // Calculate bearing for rotation
          const bearing = calculateBearing(start, end);
          
          return { position: [lng, lat], bearing };
        }
        accumulatedDistance += segmentLengths[i];
      }
      
      // Return last point
      const lastIdx = coordinates.length - 1;
      return { 
        position: coordinates[lastIdx], 
        bearing: calculateBearing(coordinates[lastIdx - 1], coordinates[lastIdx])
      };
    }

    // Process features and extract animated icons
    function extractAnimatedFeatures(geojson) {
      const animatedFeatures = [];
      
      if (!geojson || !geojson.features) return animatedFeatures;
      
      geojson.features.forEach((feature, index) => {
        const props = feature.properties || {};
        
        // Check if this feature has icon animation
        if (props['icon-animation'] && props.icon && 
            (feature.geometry.type === 'LineString' || feature.geometry.type === 'MultiLineString')) {
          
          const coordinates = feature.geometry.type === 'LineString' 
            ? feature.geometry.coordinates 
            : feature.geometry.coordinates[0]; // For MultiLineString, use first line
          
          if (coordinates && coordinates.length >= 2) {
            animatedFeatures.push({
              id: `anim-${index}`,
              coordinates,
              icon: props.icon,
              color: props['icon-color'] || '#ffffff',
              size: props['icon-size'] || 24,
              baseRotate: props['icon-rotate'] || 0,
              loop: props['icon-animation-loop'] !== false,
              speed: props['icon-animation-speed'] || 1,
              progress: 0,
              direction: 1
            });
          }
        }
      });
      
      return animatedFeatures;
    }

    // Update animated icons
    function updateAnimatedIcons() {
      if (activeAnimations.size === 0) {
        if (animationFrameId) {
          cancelAnimationFrame(animationFrameId);
          animationFrameId = null;
        }
        return;
      }

      const features = [];
      
      activeAnimations.forEach((anim, id) => {
        // Update progress based on speed (speed 1 = 30 seconds for full path)
        const increment = (anim.speed / 30) * (1/60) * anim.direction; // 60fps assumed
        anim.progress += increment;
        
        // Handle loop or stop
        if (anim.progress >= 1) {
          if (anim.loop) {
            anim.progress = 0;
          } else {
            anim.progress = 1;
          }
        } else if (anim.progress < 0) {
          if (anim.loop) {
            anim.progress = 1;
          } else {
            anim.progress = 0;
          }
        }
        
        // Get position and bearing
        const { position, bearing } = interpolateAlongLine(anim.coordinates, anim.progress);
        
        // Get or create icon
        const iconId = getOrCreateIcon(anim.icon, anim.color, anim.size);
        if (!iconId) return;
        
        // Create feature for this animated icon
        // The SVG points UP (north), so bearing 0 = north = no rotation needed
        // Add baseRotate for initial orientation adjustment
        features.push({
          type: 'Feature',
          geometry: {
            type: 'Point',
            coordinates: position
          },
          properties: {
            'icon-id': iconId,
            'icon-size': anim.size,
            'icon-rotate': bearing + anim.baseRotate
          }
        });
      });

      // Update the source
      const source = map.getSource('animated-icons-data');
      if (source) {
        source.setData({
          type: 'FeatureCollection',
          features
        });
      }

      // Continue animation
      animationFrameId = requestAnimationFrame(updateAnimatedIcons);
    }

    // Start animations for features
    function startAnimations(geojson) {
      // Stop existing animations
      activeAnimations.clear();
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }

      // Extract animated features
      const animatedFeatures = extractAnimatedFeatures(geojson);
      
      // Register animations
      animatedFeatures.forEach(anim => {
        activeAnimations.set(anim.id, anim);
      });

      // Start animation loop if we have animations
      if (activeAnimations.size > 0) {
        animationFrameId = requestAnimationFrame(updateAnimatedIcons);
      } else {
        // Clear animated icons layer if no animations
        const source = map.getSource('animated-icons-data');
        if (source) {
          source.setData({ type: 'FeatureCollection', features: [] });
        }
      }
    }

    // Extract all coordinates from a geometry
    function extractCoordinates(geometry) {
      if (!geometry) return [];
      switch (geometry.type) {
        case 'Point':
          return [geometry.coordinates];
        case 'MultiPoint':
        case 'LineString':
          return geometry.coordinates;
        case 'MultiLineString':
        case 'Polygon':
          return geometry.coordinates.flat();
        case 'MultiPolygon':
          return geometry.coordinates.flat(2);
        default:
          return [];
      }
    }

    // Extract vertices from features that have marker: true
    function extractVertices(featureCollection) {
      const vertexFeatures = [];
      if (!featureCollection || !featureCollection.features) {
        return { type: 'FeatureCollection', features: [] };
      }
      featureCollection.features.forEach(feature => {
        // Only process if marker property is true
        if (!feature.properties || feature.properties.marker !== true) {
          return;
        }
        // Skip Point geometries (they are already displayed as points)
        if (feature.geometry && feature.geometry.type === 'Point') {
          return;
        }
        const props = feature.properties;
        const markerColor = props['marker-color'] || props['stroke-color'] || '#ff6b35';
        const markerOpacity = props['marker-opacity'];
        const markerWidth = props['marker-width'];
        const coords = extractCoordinates(feature.geometry);
        coords.forEach(coord => {
          const vertexProps = { 'marker-color': markerColor };
          if (markerOpacity !== undefined) vertexProps['marker-opacity'] = markerOpacity;
          if (markerWidth !== undefined) vertexProps['marker-width'] = markerWidth;
          vertexFeatures.push({
            type: 'Feature',
            geometry: { type: 'Point', coordinates: coord },
            properties: vertexProps
          });
        });
      });
      return { type: 'FeatureCollection', features: vertexFeatures };
    }

    // Highlight layer animation state
    let highlightAnimationId = null;
    let highlightVisible = true;

    // Function to update highlight layer with current feature
    function updateHighlightLayer(feature) {
      if (!map.getSource('highlight-data')) return;

      // Stop any existing animation
      if (highlightAnimationId) {
        clearInterval(highlightAnimationId);
        highlightAnimationId = null;
      }

      if (feature && feature.geometry) {
        // Set the feature data
        map.getSource('highlight-data').setData({
          type: 'FeatureCollection',
          features: [feature]
        });

        // Center map on feature (keep current zoom level)
        const bounds = new maplibregl.LngLatBounds();
        const addCoords = (coords) => {
          if (Array.isArray(coords[0])) {
            coords.forEach(addCoords);
          } else if (coords.length >= 2) {
            bounds.extend([coords[0], coords[1]]);
          }
        };
        if (feature.geometry.coordinates) {
          addCoords(feature.geometry.coordinates);
          if (!bounds.isEmpty()) {
            const center = bounds.getCenter();
            map.flyTo({
              center: [center.lng, center.lat],
              duration: 500
            });
          }
        }

        // Start blinking animation
        highlightVisible = true;
        highlightAnimationId = setInterval(() => {
          highlightVisible = !highlightVisible;
          const opacity = highlightVisible ? 1 : 0.3;

          // Animate line width between normal+2 and normal+4
          const baseStroke = feature.properties?.['stroke-width'] || 2;
          const lineWidth = highlightVisible ? baseStroke + 4 : baseStroke + 2;

          if (map.getLayer('highlight-line')) {
            map.setPaintProperty('highlight-line', 'line-opacity', opacity);
            map.setPaintProperty('highlight-line', 'line-width', lineWidth);
          }
          if (map.getLayer('highlight-fill')) {
            map.setPaintProperty('highlight-fill', 'fill-opacity', highlightVisible ? 0.4 : 0.2);
          }
          if (map.getLayer('highlight-point')) {
            map.setPaintProperty('highlight-point', 'circle-radius', highlightVisible ? 14 : 10);
          }
        }, 500);
      } else {
        // Clear highlight
        map.getSource('highlight-data').setData({
          type: 'FeatureCollection',
          features: []
        });
      }
    }

    // Function to update map with GeoJSON data
    function updateMap(geojson) {
      if (!map.getSource('geojson-data')) {
        // Map not ready, store for later
        pendingGeojson = geojson;
        return;
      }

      try {
        map.getSource('geojson-data').setData(geojson);

        // Extract and display vertices for features with marker: true
        const vertices = extractVertices(geojson);
        if (map.getSource('vertices-data')) {
          map.getSource('vertices-data').setData(vertices);
        }

        // Fit bounds to data if there are features
        if (geojson.features && geojson.features.length > 0) {
          const bounds = new maplibregl.LngLatBounds();
          let hasValidCoords = false;

          geojson.features.forEach(feature => {
            if (!feature.geometry) return;
            const addCoords = (coords) => {
              if (Array.isArray(coords[0])) {
                coords.forEach(addCoords);
              } else if (coords.length >= 2) {
                bounds.extend([coords[0], coords[1]]);
                hasValidCoords = true;
              }
            };
            if (feature.geometry.coordinates) {
              addCoords(feature.geometry.coordinates);
            }
          });

          if (hasValidCoords) {
            map.fitBounds(bounds, {
              padding: 50,
              maxZoom: 12,
              duration: 1000
            });
          }
        }

        // Start icon animations
        startAnimations(geojson);
      } catch (e) {
        console.warn('Failed to update map:', e);
      }
    }

    // Theme CSS files mapping
    const themeCSSFiles = {
      vscode: '../themes/vscode.css',
      github: '../themes/github.css',
      monokai: '../themes/monokai.css',
      solarized: '../themes/solarized.css'
    };

    // Cache for loaded theme CSS content
    const themeCache = {};

    // Current theme style element
    let currentThemeStyle = null;

    // Load theme CSS file and apply it
    async function loadThemeCSS(themeName) {
      // Remove current theme if any
      if (currentThemeStyle) {
        currentThemeStyle.remove();
        currentThemeStyle = null;
      }

      // Empty value means default theme (no external CSS)
      if (!themeName) {
        return '';
      }

      const cssPath = themeCSSFiles[themeName];
      if (!cssPath) return '';

      // Check cache first
      if (themeCache[themeName]) {
        applyThemeCSS(themeCache[themeName]);
        return themeCache[themeName];
      }

      // Use dynamic import with ?raw to get raw CSS content (works with Vite)
      try {
        const module = await import(/* @vite-ignore */ cssPath + '?raw');
        const cssContent = module.default;
        themeCache[themeName] = cssContent;
        applyThemeCSS(cssContent);
        return cssContent;
      } catch (error) {
        console.error(`Failed to load theme ${themeName}:`, error);
        return '';
      }
    }

    // Apply theme CSS to document
    function applyThemeCSS(cssContent) {
      if (!cssContent) return;
      currentThemeStyle = document.createElement('style');
      currentThemeStyle.id = 'theme-override';
      currentThemeStyle.textContent = cssContent;
      document.head.appendChild(currentThemeStyle);
    }
    const htmlCode = document.getElementById('htmlCode');

    // Update editor attributes from inputs
    function updateEditor() {
      editor.setAttribute('placeholder', placeholderInput.value);

      const readonlyToggle = document.getElementById('readonlyToggle');
      if (readonlyToggle && readonlyToggle.checked) {
        editor.setAttribute('readonly', '');
      } else {
        editor.removeAttribute('readonly');
      }

      updateHTMLCode();
    }

    // Update HTML code display
    function updateHTMLCode() {
      const placeholder = placeholderInput.value;
      const readonlyToggle = document.getElementById('readonlyToggle');
      const internalAddToggle = document.getElementById('internalAddToggle');
      const readonly = readonlyToggle ? readonlyToggle.checked : false;
      const internalAdd = internalAddToggle ? internalAddToggle.checked : false;
      const currentTheme = themePresetMainSelect.value;

      // Build component attributes
      let attrs = [];
      if (placeholder) attrs.push(`placeholder="${placeholder.replace(/"/g, '&quot;')}"`);
      if (readonly) attrs.push('readonly');
      if (internalAdd) attrs.push('internal-add-shortcut');

      // Check current color scheme from html class (Tailwind pattern)
      const isDark = document.documentElement.classList.contains('dark');

      let code = '<!DOCTYPE html>\n';
      code += `<html lang="en"${isDark ? ' class="dark"' : ''}>\n`;
      code += '<head>\n';
      code += '  <meta charset="UTF-8">\n';
      code += '  <title>GeoJSON Editor</title>\n';

      // Include theme CSS link if a theme is selected
      if (currentTheme) {
        code += `  <!-- Theme: ${currentTheme} -->\n`;
        code += `  <link rel="stylesheet" href="https://unpkg.com/@softwarity/geojson-editor/themes/${currentTheme}.css">\n`;
      }

      code += '  <style>\n';
      code += '    /*\n';
      code += '     * Color scheme toggle (Tailwind pattern)\n';
      code += '     * The editor uses CSS light-dark() and inherits color-scheme from parent.\n';
      code += '     * Toggle html.dark class to switch themes.\n';
      code += '     * For Bootstrap: [data-bs-theme="dark"] { color-scheme: dark; }\n';
      code += '     */\n';
      code += '    html.dark { color-scheme: dark; }\n';
      code += '    html:not(.dark) { color-scheme: light; }\n';
      code += '  </style>\n';
      code += '  <script type="module">\n';
      code += '    const editor = document.querySelector(\'geojson-editor\');\n\n';
      code += '    // Valid GeoJSON - emits parsed object directly\n';
      code += '    editor.addEventListener(\'change\', (e) => {\n';
      code += '      console.log(\'GeoJSON:\', e.detail);\n';
      code += '    });\n\n';
      code += '    // Invalid JSON or GeoJSON validation error\n';
      code += '    editor.addEventListener(\'error\', (e) => {\n';
      code += '      console.error(\'Error:\', e.detail.error);\n';
      code += '    });\n\n';
      code += '    // Cursor moved to a different feature\n';
      code += '    editor.addEventListener(\'current-feature\', (e) => {\n';
      code += '      console.log(\'Current feature:\', e.detail);\n';
      code += '    });\n';
      code += '  <\/script>\n';
      code += '</head>\n';
      code += '<body>\n';
      code += '  <geojson-editor';
      if (attrs.length > 0) {
        code += '\n    ' + attrs.join('\n    ');
      }
      code += '\n  ></geojson-editor>\n\n';
      code += '  <script type="module" src="https://unpkg.com/@softwarity/geojson-editor"><\/script>\n';
      code += '</body>\n';
      code += '</html>';

      // Apply HTML syntax highlighting with Prism.js
      htmlCode.innerHTML = Prism.highlight(code, Prism.languages.markup, 'markup');
    }

    // Listen to editor change events (valid JSON parsed object)
    editor.addEventListener('change', (e) => {
      const jsonStr = JSON.stringify(e.detail, null, 2);
      // Apply Prism.js JSON highlighting
      eventLog.innerHTML = Prism.highlight(jsonStr, Prism.languages.json, 'json');
      // Clear error log on successful parse
      errorLog.textContent = 'No errors';
      errorLog.style.color = '';
      // Update map with the GeoJSON data
      updateMap(e.detail);
    });

    // Listen to editor error events (invalid JSON)
    editor.addEventListener('error', (e) => {
      errorLog.textContent = JSON.stringify(e.detail, null, 2);
      errorLog.style.color = '#f85149';
    });

    // Listen to current-feature events (cursor position tracking)
    const currentFeatureLog = document.getElementById('currentFeatureLog');
    editor.addEventListener('current-feature', (e) => {
      if (e.detail) {
        const jsonStr = JSON.stringify(e.detail, null, 2);
        currentFeatureLog.innerHTML = Prism.highlight(jsonStr, Prism.languages.json, 'json');
        // Update highlight layer on map
        updateHighlightLayer(e.detail);
      } else {
        currentFeatureLog.textContent = 'null';
        // Clear highlight layer
        updateHighlightLayer(null);
      }
    });

    // Clear event/error logs
    function clearEventLog() {
      eventLog.textContent = 'Waiting for change events...';
    }

    function clearErrorLog() {
      errorLog.textContent = 'No errors';
      errorLog.style.color = '';
    }

    // Listen to input changes
    placeholderInput.addEventListener('input', updateEditor);

    // Apply preset theme directly from main selector
    themePresetMainSelect.addEventListener('change', async () => {
      const presetName = themePresetMainSelect.value;
      await loadThemeCSS(presetName);
      updateHTMLCode();
    });

    // Toggle color scheme (light/dark) using Tailwind pattern (class on html)
    const colorSchemeToggle = document.getElementById('colorSchemeToggle');
    // Set initial icon based on html.dark class
    colorSchemeToggle.querySelector('span').textContent = document.documentElement.classList.contains('dark') ? 'dark_mode' : 'light_mode';

    function toggleColorScheme() {
      document.documentElement.classList.toggle('dark');
      const isDark = document.documentElement.classList.contains('dark');
      const iconSpan = colorSchemeToggle.querySelector('span');
      iconSpan.textContent = isDark ? 'dark_mode' : 'light_mode';
      updateHTMLCode();
    }

    // Open theme modal
    async function openThemeModal() {
      await loadCurrentThemeCSS();
      themeModal.style.display = 'flex';
      document.body.style.overflow = 'hidden';
    }

    // Close theme modal
    function closeThemeModal() {
      themeModal.style.display = 'none';
      document.body.style.overflow = '';
    }

    // Close modal on Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && themeModal.style.display === 'flex') {
        closeThemeModal();
      }
    });

    // Load current theme CSS into textarea
    async function loadCurrentThemeCSS() {
      const presetName = themePresetMainSelect.value;
      if (!presetName) {
        // Default theme - show the built-in CSS variables
        themeTextarea.value = `/* Default theme (IntelliJ) - built into the component */
/* To customize, create a CSS file with overrides: */

:root {
  /* Editor background and text */
  --geojson-editor-bg-color: light-dark(#fff, #2b2b2b);
  --geojson-editor-text-color: light-dark(#000, #a9b7c6);
  --geojson-editor-caret-color: light-dark(#000, #bbb);

  /* Gutter (line numbers area) */
  --geojson-editor-gutter-bg: light-dark(#f0f0f0, #313335);
  --geojson-editor-gutter-border: light-dark(#e0e0e0, #3c3f41);
  --geojson-editor-gutter-text: light-dark(#999, #606366);

  /* JSON syntax highlighting */
  --geojson-editor-json-key: light-dark(#660e7a, #9876aa);
  --geojson-editor-json-string: light-dark(#008000, #6a8759);
  --geojson-editor-json-number: light-dark(#00f, #6897bb);
  --geojson-editor-json-boolean: light-dark(#000080, #cc7832);
  --geojson-editor-json-punct: light-dark(#000, #a9b7c6);
  --geojson-editor-json-error: light-dark(#f00, #ff6b68);

  /* GeoJSON-specific */
  --geojson-editor-geojson-key: light-dark(#660e7a, #9876aa);
  --geojson-editor-geojson-type: light-dark(#008000, #6a8759);
  --geojson-editor-geojson-type-invalid: light-dark(#f00, #ff6b68);

  /* Controls (checkboxes, color swatches) */
  --geojson-editor-control-color: light-dark(#000080, #cc7832);
  --geojson-editor-control-bg: light-dark(#e8e8e8, #3c3f41);
  --geojson-editor-control-border: light-dark(#c0c0c0, #5a5a5a);

  /* Selection and errors */
  --geojson-editor-selection-color: light-dark(rgba(51, 153, 255, 0.3), rgba(51, 153, 255, 0.4));
  --geojson-editor-error-color: light-dark(#dc3545, #ff6b68);
}`;
        return;
      }

      const cssPath = themeCSSFiles[presetName];
      if (!cssPath) return;

      // Check cache first
      if (themeCache[presetName]) {
        themeTextarea.value = themeCache[presetName];
        return;
      }

      // Fetch CSS file
      try {
        const response = await fetch(cssPath);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const cssContent = await response.text();
        themeCache[presetName] = cssContent;
        themeTextarea.value = cssContent;
      } catch (error) {
        themeTextarea.value = `/* Failed to load theme: ${error.message} */`;
      }
    }

    // Apply theme from textarea (custom CSS)
    function applyTheme() {
      try {
        const cssContent = themeTextarea.value;
        // Remove current theme
        if (currentThemeStyle) {
          currentThemeStyle.remove();
          currentThemeStyle = null;
        }
        // Apply custom CSS
        if (cssContent.trim()) {
          applyThemeCSS(cssContent);
        }
        showThemeMessage('Theme applied!', 'success');
      } catch (e) {
        showThemeMessage('Failed to apply: ' + e.message, 'error');
      }
    }

    // Reset to default theme
    async function resetTheme() {
      themePresetMainSelect.value = '';
      if (currentThemeStyle) {
        currentThemeStyle.remove();
        currentThemeStyle = null;
      }
      await loadCurrentThemeCSS();
      updateHTMLCode();
      showThemeMessage('Theme reset to default', 'success');
    }

    // Copy theme CSS to clipboard
    function copyTheme() {
      const cssContent = themeTextarea.value;

      navigator.clipboard.writeText(cssContent).then(() => {
        showThemeMessage('CSS copied to clipboard!', 'success');
      }).catch(() => {
        showThemeMessage('Failed to copy', 'error');
      });
    }

    // Show feedback message as centered toast overlay in theme modal
    function showThemeMessage(message, type) {
      const modalContent = themeModal.querySelector('.modal-content');
      const existing = modalContent.querySelector('.theme-toast');
      if (existing) existing.remove();

      const toast = document.createElement('div');
      toast.className = 'theme-toast';
      toast.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 1rem 1.5rem;
        border-radius: 8px;
        font-size: 0.95rem;
        font-weight: 500;
        background: ${type === 'success' ? 'rgba(40, 167, 69, 0.95)' : 'rgba(220, 53, 69, 0.95)'};
        color: white;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        z-index: 10;
        animation: toastFadeIn 0.2s ease-out;
      `;
      toast.textContent = message;
      modalContent.style.position = 'relative';
      modalContent.appendChild(toast);

      setTimeout(() => {
        toast.style.animation = 'toastFadeOut 0.3s ease-out forwards';
        setTimeout(() => toast.remove(), 300);
      }, 2000);
    }

    // ========================================
    // API Modal Functions
    // ========================================
    const apiModal = document.getElementById('apiModal');
    const apiModalTitle = document.getElementById('apiModalTitle');
    const apiModalError = document.getElementById('apiModalError');
    let currentApiMethod = null;

    // Cache for loaded samples
    const apiSampleCache = {};

    // Get selected collapsed attributes for a method
    function getCollapsedAttributes(method) {
      const methodName = method.charAt(0).toUpperCase() + method.slice(1);
      const form = document.getElementById(`apiForm${methodName}`);
      if (!form) return ['coordinates'];

      const checkboxes = form.querySelectorAll('.collapsed-checkboxes input[type="checkbox"]:checked');
      return Array.from(checkboxes).map(cb => cb.value);
    }

    // Get format label for display
    function getFormatLabel(format) {
      const labels = {
        'feature-collection': 'featureCollection',
        'features': 'features',
        'feature': 'feature'
      };
      return labels[format] || format;
    }

    // Update API call preview
    function updateApiCallPreview(method) {
      const methodName = method.charAt(0).toUpperCase() + method.slice(1);
      const formatSelect = document.getElementById(`api${methodName}Format`);
      const previewDiv = document.getElementById(`api${methodName}CallPreview`);
      const defaultHint = document.getElementById(`api${methodName}DefaultHint`);

      if (!formatSelect || !previewDiv) return;

      const format = formatSelect.value;
      const formatLabel = getFormatLabel(format);
      const collapsed = getCollapsedAttributes(method);

      // Show/hide default hint based on selection
      const isUsingDefault = collapsed.length === 0;
      if (defaultHint) {
        defaultHint.style.display = isUsingDefault ? 'inline' : 'none';
      }

      // Build code string with proper formatting
      let callStr = '';
      if (method === 'set') {
        if (isUsingDefault) {
          callStr = `editor.set(${formatLabel});`;
        } else {
          callStr = `editor.set(${formatLabel}, {\n  collapsed: ${JSON.stringify(collapsed)}\n});`;
        }
      } else if (method === 'add') {
        if (isUsingDefault) {
          callStr = `editor.add(${formatLabel});`;
        } else {
          callStr = `editor.add(${formatLabel}, {\n  collapsed: ${JSON.stringify(collapsed)}\n});`;
        }
      } else if (method === 'insertAt') {
        const index = document.getElementById('apiInsertAtIndex')?.value || '0';
        if (isUsingDefault) {
          callStr = `editor.insertAt(${formatLabel}, ${index});`;
        } else {
          callStr = `editor.insertAt(${formatLabel}, ${index}, {\n  collapsed: ${JSON.stringify(collapsed)}\n});`;
        }
      }

      // Apply Prism.js highlighting
      const highlighted = Prism.highlight(callStr, Prism.languages.javascript, 'javascript');
      previewDiv.querySelector('code').innerHTML = highlighted;
    }

    // Load sample file for API method
    async function loadApiSample(method) {
      const formatSelect = document.getElementById(`api${method.charAt(0).toUpperCase() + method.slice(1)}Format`);
      const previewDiv = document.getElementById(`api${method.charAt(0).toUpperCase() + method.slice(1)}Preview`);
      const format = formatSelect.value;
      const filename = `./samples/${method}.${format}.geojson`;
      const cacheKey = `${method}-${format}`;

      try {
        let data;
        if (apiSampleCache[cacheKey]) {
          data = apiSampleCache[cacheKey];
        } else {
          const response = await fetch(filename);
          if (!response.ok) throw new Error(`Failed to load ${filename}`);
          data = await response.text();
          apiSampleCache[cacheKey] = data;
        }

        // Apply Prism.js highlighting
        const highlighted = Prism.highlight(data, Prism.languages.json, 'json');
        previewDiv.querySelector('code').innerHTML = highlighted;
      } catch (error) {
        console.error('Failed to load sample:', error);
        previewDiv.querySelector('code').textContent = `Error: ${error.message}`;
      }
    }

    // Open API modal for a specific method
    function openApiModal(method) {
      currentApiMethod = method;

      // Hide all forms
      document.querySelectorAll('[id^="apiForm"]').forEach(el => el.style.display = 'none');
      apiModalError.style.display = 'none';

      // Show the relevant form
      const formId = 'apiForm' + method.charAt(0).toUpperCase() + method.slice(1);
      const form = document.getElementById(formId);
      if (form) form.style.display = 'block';

      // Update title
      const titles = {
        set: 'set(input)',
        add: 'add(input)',
        insertAt: 'insertAt(input, index)',
        removeAt: 'removeAt(index)'
      };
      apiModalTitle.textContent = titles[method] || method;

      // Load sample and update API call preview for set/add/insertAt
      if (method === 'set' || method === 'add' || method === 'insertAt') {
        loadApiSample(method);
        updateApiCallPreview(method);
      }

      apiModal.style.display = 'flex';
      document.body.style.overflow = 'hidden';
    }

    // Close API modal
    function closeApiModal() {
      apiModal.style.display = 'none';
      document.body.style.overflow = '';
      currentApiMethod = null;
    }

    // Execute the current API method
    function executeApiMethod() {
      apiModalError.style.display = 'none';

      try {
        switch (currentApiMethod) {
          case 'set': {
            const format = document.getElementById('apiSetFormat').value;
            const cacheKey = `set-${format}`;
            const data = apiSampleCache[cacheKey];
            if (!data) throw new Error('Sample not loaded');
            const parsed = JSON.parse(data);
            const collapsed = getCollapsedAttributes('set');
            // If nothing selected, use default (no options = ['coordinates'])
            if (collapsed.length === 0) {
              editor.set(parsed);
            } else {
              editor.set(parsed, { collapsed });
            }
            break;
          }
          case 'add': {
            const format = document.getElementById('apiAddFormat').value;
            const cacheKey = `add-${format}`;
            const data = apiSampleCache[cacheKey];
            if (!data) throw new Error('Sample not loaded');
            const parsed = JSON.parse(data);
            const collapsed = getCollapsedAttributes('add');
            // If nothing selected, use default (no options = ['coordinates'])
            if (collapsed.length === 0) {
              editor.add(parsed);
            } else {
              editor.add(parsed, { collapsed });
            }
            break;
          }
          case 'insertAt': {
            const format = document.getElementById('apiInsertAtFormat').value;
            const cacheKey = `insertAt-${format}`;
            const data = apiSampleCache[cacheKey];
            if (!data) throw new Error('Sample not loaded');
            const parsed = JSON.parse(data);
            const index = parseInt(document.getElementById('apiInsertAtIndex').value, 10);
            const collapsed = getCollapsedAttributes('insertAt');
            // If nothing selected, use default (no options = ['coordinates'])
            if (collapsed.length === 0) {
              editor.insertAt(parsed, index);
            } else {
              editor.insertAt(parsed, index, { collapsed });
            }
            break;
          }
          case 'removeAt': {
            const indexInput = document.getElementById('apiRemoveAtIndex');
            const index = parseInt(indexInput.value, 10);
            const removed = editor.removeAt(index);
            if (removed === undefined) {
              throw new Error('Index out of bounds');
            }
            break;
          }
        }
        closeApiModal();
      } catch (e) {
        apiModalError.textContent = e.message;
        apiModalError.style.display = 'block';
      }
    }

    // Direct API actions (no modal)
    function apiRemoveAll() {
      editor.removeAll();
    }

    function apiEmit() {
      editor.emit();
    }

    // Close API modal on Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && apiModal.style.display === 'flex') {
        closeApiModal();
      }
    });

    // Sample GeoJSON will be loaded from external file
    let sampleFeaturesArray = [];

    // Load sample data (always in FeatureCollection mode - just the features array content)
    async function loadSampleData() {
      try {
        const response = await fetch('./sample.geojson');
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const geojson = await response.json();
        console.log('Loaded sample.geojson with', geojson.length, 'features');
        editor.set(geojson);
      } catch (error) {
        console.error('Failed to load sample.geojson:', error);
        // Fallback to empty editor
        editor.removeAll();
      }
    }

    function clearEditor() {
      editor.removeAll();
    }

    // Toggle readonly mode
    function toggleReadonly() {
      const readonlyToggle = document.getElementById('readonlyToggle');

      if (readonlyToggle.checked) {
        editor.setAttribute('readonly', '');
      } else {
        editor.removeAttribute('readonly');
      }

      updateHTMLCode();
    }

    // Toggle internal add shortcut (Ctrl+I)
    function toggleInternalAdd() {
      const internalAddToggle = document.getElementById('internalAddToggle');

      if (internalAddToggle.checked) {
        editor.setAttribute('internal-add-shortcut', '');
      } else {
        editor.removeAttribute('internal-add-shortcut');
      }

      updateHTMLCode();
    }

    // Reset editor to original sample data
    function resetEditor() {
      loadSampleData();
    }

    // Load initial sample automatically after component is ready
    customElements.whenDefined('geojson-editor').then(() => {
      updateEditor();
      loadSampleData();
    });
  </script>
  <script type="module" src="../src/geojson-editor.js"></script>
</body>
</html>
