<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GeoJSON Editor Demo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      padding: 2rem;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }

    h1 {
      color: #333;
      margin-bottom: 1rem;
      font-size: 2rem;
    }

    .description {
      color: #666;
      margin-bottom: 2rem;
      line-height: 1.6;
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      margin-bottom: 2rem;
      padding: 1.5rem;
      background: #f5f5f5;
      border-radius: 8px;
    }

    .controls-section {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .controls-section h4 {
      margin: 0;
      color: #333;
      font-size: 1rem;
      border-bottom: 2px solid #667eea;
      padding-bottom: 0.5rem;
    }

    .controls-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 1rem;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .control-group label {
      font-weight: 600;
      color: #555;
      font-size: 0.9rem;
    }

    .control-group select,
    .control-group input[type="text"],
    .control-group textarea {
      padding: 0.5rem;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 0.9rem;
      font-family: 'Courier New', monospace;
    }

    .control-group textarea {
      resize: vertical;
      min-height: 60px;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .checkbox-group label {
      margin: 0;
    }

    .editor-container {
      margin-top: 2rem;
      border: 2px solid #e0e0e0;
      border-radius: 8px;
      overflow: hidden;
    }

    .output {
      margin-top: 2rem;
      padding: 1rem;
      background: #f9f9f9;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
    }

    .output h3 {
      color: #333;
      margin-bottom: 0.5rem;
    }

    .output pre {
      background: white;
      padding: 1rem;
      border-radius: 4px;
      max-height: 400px;
      overflow-x: auto;
      overflow-y: auto;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
    }

    button {
      padding: 0.5rem 1rem;
      background: #667eea;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
      transition: background 0.2s;
    }

    button:hover {
      background: #5568d3;
    }

    .theme-editor {
      margin-top: 2rem;
      padding: 1.5rem;
      background: #f9f9f9;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
    }

    .theme-editor h3 {
      margin-top: 0;
      color: #333;
    }

    .theme-controls label {
      display: block;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: #555;
    }

    #themeTextarea {
      width: 100%;
      padding: 1rem;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 0.9rem;
      background: white;
      resize: vertical;
    }

    .theme-actions {
      margin-top: 1rem;
      display: flex;
      gap: 1rem;
    }

    .header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 1rem;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .header h1 {
      margin: 0;
      flex: 1;
    }

    .github-link {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 1rem;
      background: #24292e;
      color: white;
      text-decoration: none;
      border-radius: 6px;
      font-weight: 600;
      font-size: 0.9rem;
      transition: background 0.2s;
    }

    .github-link:hover {
      background: #1b1f23;
    }

    .github-link svg {
      width: 20px;
      height: 20px;
      fill: currentColor;
    }

    .code-example {
      margin-top: 2rem;
      padding: 1rem;
      background: #f9f9f9;
      border-radius: 8px;
      border: 1px solid #e0e0e0;
    }

    .code-example h3 {
      color: #333;
      margin-bottom: 0.5rem;
    }

    .code-example pre {
      background: #1e1e1e;
      padding: 1rem;
      border-radius: 4px;
      overflow-x: auto;
      font-family: 'Courier New', monospace;
      font-size: 0.85rem;
      line-height: 1.5;
      margin: 0;
      color: #d4d4d4;
    }

    /* Prism.js VSCode Dark theme (default) */
    .code-example.theme-dark .token.comment,
    .code-example.theme-dark .token.prolog,
    .code-example.theme-dark .token.doctype { color: #6a9955; }

    .code-example.theme-dark .token.punctuation { color: #d4d4d4; }

    .code-example.theme-dark .token.property,
    .code-example.theme-dark .token.tag,
    .code-example.theme-dark .token.boolean,
    .code-example.theme-dark .token.number,
    .code-example.theme-dark .token.constant,
    .code-example.theme-dark .token.symbol { color: #569cd6; }

    .code-example.theme-dark .token.selector,
    .code-example.theme-dark .token.attr-name,
    .code-example.theme-dark .token.string,
    .code-example.theme-dark .token.char,
    .code-example.theme-dark .token.builtin { color: #ce9178; }

    .code-example.theme-dark .token.operator,
    .code-example.theme-dark .token.entity,
    .code-example.theme-dark .token.url,
    .code-example.theme-dark .token.variable { color: #d4d4d4; }

    .code-example.theme-dark .token.atrule,
    .code-example.theme-dark .token.attr-value,
    .code-example.theme-dark .token.keyword { color: #569cd6; }

    .code-example.theme-dark .token.function { color: #dcdcaa; }

    .code-example.theme-dark .token.regex,
    .code-example.theme-dark .token.important { color: #d16969; }

    /* Prism.js VSCode Light theme */
    .code-example.theme-light {
      background: #ffffff;
    }

    .code-example.theme-light pre {
      background: #ffffff;
      color: #000000;
    }

    .code-example.theme-light .token.comment,
    .code-example.theme-light .token.prolog,
    .code-example.theme-light .token.doctype { color: #008000; }

    .code-example.theme-light .token.punctuation { color: #000000; }

    .code-example.theme-light .token.property,
    .code-example.theme-light .token.tag,
    .code-example.theme-light .token.boolean,
    .code-example.theme-light .token.number,
    .code-example.theme-light .token.constant,
    .code-example.theme-light .token.symbol { color: #0000ff; }

    .code-example.theme-light .token.selector,
    .code-example.theme-light .token.attr-name,
    .code-example.theme-light .token.string,
    .code-example.theme-light .token.char,
    .code-example.theme-light .token.builtin { color: #a31515; }

    .code-example.theme-light .token.operator,
    .code-example.theme-light .token.entity,
    .code-example.theme-light .token.url,
    .code-example.theme-light .token.variable { color: #000000; }

    .code-example.theme-light .token.atrule,
    .code-example.theme-light .token.attr-value,
    .code-example.theme-light .token.keyword { color: #0000ff; }

    .code-example.theme-light .token.function { color: #795e26; }

    .code-example.theme-light .token.regex,
    .code-example.theme-light .token.important { color: #ff0000; }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>GeoJSON Editor Component Demo</h1>
      <a href="https://github.com/softwarity/geojson-editor" target="_blank" rel="noopener noreferrer" class="github-link">
        <svg viewBox="0 0 16 16" aria-hidden="true">
          <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"></path>
        </svg>
        View on GitHub
      </a>
    </div>
    <div class="description">
      This demo showcases the &lt;geojson-editor&gt; Web Component with syntax highlighting,
      collapsible nodes, and automatic color picker detection.
      <br><br>
      <strong>Color Detection:</strong> The editor automatically detects hex colors (#RRGGBB) in any JSON string value
      and displays a color indicator in the gutter. Click it to open a color picker!
    </div>

    <div class="controls">
      <div class="controls-section">
        <h4>Theme Detection</h4>
        <div class="controls-grid">
          <div class="control-group">
            <label for="frameworkSelect">Framework</label>
            <select id="frameworkSelect">
              <option value="custom" selected>Custom</option>
              <option value="tailwind">Tailwind CSS</option>
              <option value="bootstrap">Bootstrap</option>
            </select>
          </div>
          <div class="control-group">
            <label for="colorSchemeSelect">Color Scheme</label>
            <select id="colorSchemeSelect">
              <option value="dark" selected>Dark</option>
              <option value="light">Light</option>
            </select>
          </div>
        </div>
        <div id="frameworkDescription" style="background: #e8f4fd; padding: 0.75rem; border-radius: 4px; margin-bottom: 1rem; font-size: 0.85rem; color: #1a5276; border-left: 3px solid #3498db;">
          <strong>Custom:</strong> Dark mode is detected via a <code>.dark</code> class directly on the <code>&lt;geojson-editor&gt;</code> component itself.
        </div>
        <div class="controls-grid">
          <div class="control-group">
            <label for="selectorPreview">Dark Selector</label>
            <input type="text" id="selectorPreview" value="dark-selector='.dark'" readonly style="font-size: 0.8rem; background: #e9e9e9;">
          </div>
        </div>
      </div>

      <div class="controls-section">
        <h4>Collapsed Nodes</h4>
        <div class="controls-grid">
          <div class="control-group">
            <label for="collapsedInput">Initially Collapsed Keys</label>
            <input type="text" id="collapsedInput" value='["coordinates"]'>
            <small style="color: #666; font-size: 0.85rem;">JSON array of property keys to collapse on load (e.g., <code>["coordinates", "properties"]</code>)</small>
          </div>
        </div>
      </div>

      <div class="controls-section">
        <h4>Editor Options</h4>
        <div class="control-group" style="margin-bottom: 1rem;">
          <label for="placeholderInput">Placeholder Text</label>
          <input type="text" id="placeholderInput" value="Enter GeoJSON features here...">
          <small style="color: #666; font-size: 0.85rem;">Shown when editor is empty</small>
        </div>
        <div style="display: flex; gap: 2rem; flex-wrap: wrap;">
          <div class="checkbox-group">
            <input type="checkbox" id="featureCollectionCheck" checked>
            <label for="featureCollectionCheck">FeatureCollection mode</label>
            <small style="color: #888; font-size: 0.8rem; margin-left: 0.5rem;">— wrap features in FeatureCollection</small>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="autoFormatCheck" checked>
            <label for="autoFormatCheck">Auto-format JSON</label>
            <small style="color: #888; font-size: 0.8rem; margin-left: 0.5rem;">— indent in real-time</small>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="readonlyCheck">
            <label for="readonlyCheck">Readonly mode</label>
            <small style="color: #888; font-size: 0.8rem; margin-left: 0.5rem;">— disable editing</small>
          </div>
        </div>
      </div>
    </div>

    <div class="editor-container">
      <geojson-editor id="editor"></geojson-editor>
    </div>

    <div class="output">
      <h3>Change Events:</h3>
      <p style="color: #666; font-size: 0.85rem; margin-bottom: 0.5rem;">
        The component emits <code>change</code> events with <code>e.detail</code> containing the parsed GeoJSON object directly.
      </p>
      <pre id="eventLog">Waiting for change events...</pre>
    </div>

    <div class="output" style="background: #fff5f5; border-color: #ffcccc;">
      <h3 style="color: #c53030;">Error Events:</h3>
      <p style="color: #666; font-size: 0.85rem; margin-bottom: 0.5rem;">
        When JSON is invalid, the component emits <code>error</code> events with:
        <strong>timestamp</strong>,
        <strong>error</strong> (error message),
        <strong>content</strong> (editor content for debugging)
      </p>
      <pre id="errorLog">No errors</pre>
    </div>

    <div class="code-example theme-dark" id="codeExample">
      <h3>HTML Code:</h3>
      <p style="color: #666; font-size: 0.85rem; margin-bottom: 0.5rem;">
        Copy this code to use the component in your own page (updates automatically with your settings)
      </p>
      <pre id="htmlCode"></pre>
    </div>

    <div class="theme-editor" id="themeEditor" style="display: none;">
      <h3>Theme Editor</h3>
      <div class="theme-controls">
        <label>
          Edit theme colors (JSON format):
          <textarea id="themeTextarea" rows="15" spellcheck="false"></textarea>
        </label>
        <div class="theme-actions">
          <button onclick="applyTheme()">Apply Theme</button>
          <button onclick="resetTheme()">Reset to Default</button>
        </div>
      </div>
    </div>
  </div>

  
  <script>
    const editor = document.getElementById('editor');
    const eventLog = document.getElementById('eventLog');
    const errorLog = document.getElementById('errorLog');
    const placeholderInput = document.getElementById('placeholderInput');
    const collapsedInput = document.getElementById('collapsedInput');
    const frameworkSelect = document.getElementById('frameworkSelect');
    const colorSchemeSelect = document.getElementById('colorSchemeSelect');
    const selectorPreview = document.getElementById('selectorPreview');
    const readonlyCheck = document.getElementById('readonlyCheck');
    const autoFormatCheck = document.getElementById('autoFormatCheck');
    const featureCollectionCheck = document.getElementById('featureCollectionCheck');
    const themeEditor = document.getElementById('themeEditor');
    const themeTextarea = document.getElementById('themeTextarea');
    const htmlCode = document.getElementById('htmlCode');
    const codeExample = document.getElementById('codeExample');

    // Internal dark selector value
    let darkSelector = '.dark';

    // Framework presets (only dark selector needed)
    const frameworkPresets = {
      custom: '.dark',
      tailwind: 'html.dark',
      bootstrap: 'html[data-bs-theme=dark]'
    };

    // Framework descriptions
    const frameworkDescriptions = {
      custom: '<strong>Custom:</strong> Dark mode is detected via a <code>.dark</code> class directly on the <code>&lt;geojson-editor&gt;</code> component itself.',
      tailwind: '<strong>Tailwind CSS:</strong> Dark mode is detected via the <code>.dark</code> class on the <code>&lt;html&gt;</code> element, following Tailwind\'s dark mode convention.',
      bootstrap: '<strong>Bootstrap:</strong> Dark mode is detected via the <code>data-bs-theme="dark"</code> attribute on the <code>&lt;html&gt;</code> element.'
    };

    const frameworkDescription = document.getElementById('frameworkDescription');

    // Handle framework selection
    frameworkSelect.addEventListener('change', (e) => {
      const preset = frameworkPresets[e.target.value];
      if (preset) {
        darkSelector = preset;
        selectorPreview.value = `dark-selector="${darkSelector}"`;
        frameworkDescription.innerHTML = frameworkDescriptions[e.target.value];
        updateEditor();
        applyColorScheme(); // Apply the current color scheme to the new target
      }
    });

    // Parse dark selector to determine target element
    function parseSelector(selector) {
      // Check for class on component itself (.dark)
      if (selector.startsWith('.') && !selector.includes(' ')) {
        return {
          target: 'component',
          type: 'class',
          value: selector.substring(1) // Remove the dot
        };
      }

      // Check for class on html (html.dark)
      const htmlClassMatch = selector.match(/^html\.(.+)$/);
      if (htmlClassMatch) {
        return {
          target: 'html',
          type: 'class',
          value: htmlClassMatch[1]
        };
      }

      // Check for attribute on html (html[data-bs-theme=dark])
      const htmlAttrMatch = selector.match(/^html\[([^=]+)=([^\]]+)\]$/);
      if (htmlAttrMatch) {
        return {
          target: 'html',
          type: 'attribute',
          attr: htmlAttrMatch[1],
          value: htmlAttrMatch[2]
        };
      }

      return null;
    }

    // Apply color scheme by modifying the appropriate target
    function applyColorScheme() {
      const scheme = colorSchemeSelect.value;
      const isDark = scheme === 'dark';

      const target = parseSelector(darkSelector);
      if (!target) return;

      // Apply to component
      if (target.target === 'component') {
        if (isDark) {
          editor.classList.add(target.value);
        } else {
          editor.classList.remove(target.value);
        }
      }

      // Apply to html element
      if (target.target === 'html') {
        if (target.type === 'class') {
          if (isDark) {
            document.documentElement.classList.add(target.value);
          } else {
            document.documentElement.classList.remove(target.value);
          }
        } else if (target.type === 'attribute') {
          // For Bootstrap: set attribute to "dark" or "light"
          document.documentElement.setAttribute(target.attr, scheme);
        }
      }

      // Update code example theme
      codeExample.classList.remove('theme-dark', 'theme-light');
      codeExample.classList.add(`theme-${scheme}`);
    }

    // Update editor attributes from inputs
    function updateEditor() {
      editor.setAttribute('placeholder', placeholderInput.value);
      editor.setAttribute('collapsed', collapsedInput.value);
      editor.setAttribute('dark-selector', darkSelector);

      if (featureCollectionCheck.checked) {
        editor.setAttribute('feature-collection', '');
      } else {
        editor.removeAttribute('feature-collection');
      }

      if (autoFormatCheck.checked) {
        editor.setAttribute('auto-format', '');
      } else {
        editor.removeAttribute('auto-format');
      }

      if (readonlyCheck.checked) {
        editor.setAttribute('readonly', '');
      } else {
        editor.removeAttribute('readonly');
      }

      updateHTMLCode();
    }

    // Update HTML code display
    function updateHTMLCode() {
      const placeholder = placeholderInput.value;
      const collapsed = collapsedInput.value;
      const readonly = readonlyCheck.checked;
      const autoFormat = autoFormatCheck.checked;
      const featureCollection = featureCollectionCheck.checked;
      const framework = frameworkSelect.value;
      const scheme = colorSchemeSelect.value;

      // Build component attributes
      let attrs = [];
      if (featureCollection) attrs.push('feature-collection');
      if (collapsed && collapsed !== '[]') attrs.push(`collapsed='${collapsed.replace(/'/g, "\\'")}'`);
      if (placeholder) attrs.push(`placeholder="${placeholder.replace(/"/g, '&quot;')}"`);
      if (autoFormat) attrs.push('auto-format');
      if (readonly) attrs.push('readonly');
      if (darkSelector) attrs.push(`dark-selector="${darkSelector.replace(/"/g, '&quot;')}"`);

      // Build HTML tag attributes based on framework and scheme
      let htmlAttrs = 'lang="en"';
      if (framework === 'tailwind' && scheme === 'dark') {
        htmlAttrs += ' class="dark"';
      } else if (framework === 'bootstrap') {
        htmlAttrs += ` data-bs-theme="${scheme}"`;
      }

      // Build component class attribute for custom framework (only add dark class)
      let componentClass = '';
      if (framework === 'custom' && scheme === 'dark') {
        componentClass = ' class="dark"';
      }

      let code = '<!DOCTYPE html>\n';
      code += `<html ${htmlAttrs}>\n`;
      code += '<head>\n';
      code += '  <meta charset="UTF-8">\n';
      code += '  <title>GeoJSON Editor</title>\n';
      code += '  <!-- Load the GeoJSON Editor web component -->\n';
      code += '  <script type="module" src="https://unpkg.com/@softwarity/geojson-editor"><\/script>\n';
      code += '</head>\n';
      code += '<body>\n';
      code += `  <geojson-editor${componentClass}\n`;
      code += '    ' + attrs.join('\n    ') + '\n';
      code += '  ></geojson-editor>\n\n';
      code += '  <script type="module">\n';
      code += '    const editor = document.querySelector(\'geojson-editor\');\n\n';
      code += '    // Valid GeoJSON - emits parsed object directly\n';
      code += '    editor.addEventListener(\'change\', (e) => {\n';
      code += '      console.log(\'GeoJSON:\', e.detail);\n';
      code += '    });\n\n';
      code += '    // Invalid JSON or GeoJSON validation error\n';
      code += '    editor.addEventListener(\'error\', (e) => {\n';
      code += '      console.error(\'Error:\', e.detail.error);\n';
      code += '    });\n\n';

      // Add theme toggle example based on framework
      if (framework === 'custom') {
        code += '    // Toggle dark mode by adding/removing .dark class on the component\n';
        code += '    function toggleDarkMode() {\n';
        code += '      editor.classList.toggle(\'dark\');\n';
        code += '    }\n';
      } else if (framework === 'tailwind') {
        code += '    // Toggle dark mode (Tailwind style - class on html)\n';
        code += '    function toggleDarkMode() {\n';
        code += '      document.documentElement.classList.toggle(\'dark\');\n';
        code += '    }\n';
      } else if (framework === 'bootstrap') {
        code += '    // Toggle theme (Bootstrap style - attribute on html)\n';
        code += '    function toggleDarkMode() {\n';
        code += '      const html = document.documentElement;\n';
        code += '      const current = html.getAttribute(\'data-bs-theme\');\n';
        code += '      html.setAttribute(\'data-bs-theme\', current === \'dark\' ? \'light\' : \'dark\');\n';
        code += '    }\n';
      }

      code += '  <\/script>\n';
      code += '</body>\n';
      code += '</html>';

      // Apply HTML syntax highlighting with Prism.js
      htmlCode.innerHTML = Prism.highlight(code, Prism.languages.markup, 'markup');
    }

    // Listen to editor change events (valid JSON parsed object)
    editor.addEventListener('change', (e) => {
      eventLog.textContent = JSON.stringify(e.detail, null, 2);
      // Clear error log on successful parse
      errorLog.textContent = 'No errors';
      errorLog.style.color = '';
    });

    // Listen to editor error events (invalid JSON)
    editor.addEventListener('error', (e) => {
      errorLog.textContent = JSON.stringify(e.detail, null, 2);
      errorLog.style.color = '#c53030';
    });

    // Listen to input changes
    placeholderInput.addEventListener('input', updateEditor);
    collapsedInput.addEventListener('input', updateEditor);

    // Handle feature-collection mode toggle: reload sample data in appropriate format
    featureCollectionCheck.addEventListener('change', () => {
      updateEditor();
      loadSampleData();
    });
    readonlyCheck.addEventListener('change', updateEditor);
    autoFormatCheck.addEventListener('change', updateEditor);

    // Color scheme change - applies to the selector target and updates HTML code
    colorSchemeSelect.addEventListener('change', () => {
      applyColorScheme();
      updateHTMLCode(); // Update the generated HTML code to reflect the new scheme
    });

    // Toggle theme editor
    function toggleThemeEditor() {
      const isVisible = themeEditor.style.display !== 'none';
      if (isVisible) {
        themeEditor.style.display = 'none';
      } else {
        themeEditor.style.display = 'block';
        loadCurrentTheme();
      }
    }

    // Load current theme into textarea
    function loadCurrentTheme() {
      const theme = editor.getTheme();
      themeTextarea.value = JSON.stringify(theme, null, 2);
    }

    // Apply theme from textarea
    function applyTheme() {
      try {
        const theme = JSON.parse(themeTextarea.value);
        editor.setTheme(theme);
        alert('Theme applied successfully!');
      } catch (e) {
        alert('Invalid JSON: ' + e.message);
      }
    }

    // Reset to default theme
    function resetTheme() {
      editor.resetTheme();
      loadCurrentTheme();
      alert('Theme reset to default!');
    }

    // Sample features array
    const sampleFeaturesArray = [
      {
        type: "Feature",
        geometry: { type: "Point", coordinates: [166.4581, -22.2758] },
        properties: { name: "Noumea Airport", type: "airport", color: "#3498db", category: "airport" }
      },
      {
        type: "Feature",
        geometry: { type: "LineString", coordinates: [[166.4, -22.2], [167.0, -22.5], [167.5, -23.0]] },
        properties: { name: "Flight Path", color: "#e74c3c", width: 2 }
      },
      {
        type: "Feature",
        geometry: {
          type: "Polygon",
          coordinates: [[[166.0, -22.0], [167.0, -22.0], [167.0, -23.0], [166.0, -23.0], [166.0, -22.0]]]
        },
        properties: { name: "Coverage Area", fill: "#2ecc71", stroke: "#27ae60", opacity: 0.5 }
      }
    ];

    // Load sample data in appropriate format based on mode
    function loadSampleData() {
      if (featureCollectionCheck.checked) {
        // Feature-collection mode: just the features (comma-separated)
        const featuresStr = sampleFeaturesArray.map(f => JSON.stringify(f, null, 2)).join(',\n');
        editor.setAttribute('value', featuresStr);
      } else {
        // Standalone mode: full FeatureCollection
        const featureCollection = { type: "FeatureCollection", features: sampleFeaturesArray };
        editor.setAttribute('value', JSON.stringify(featureCollection, null, 2));
      }
    }

    function clearEditor() {
      editor.setAttribute('value', '');
    }

    // Load initial sample automatically after component is ready
    customElements.whenDefined('geojson-editor').then(() => {
      updateEditor();
      applyColorScheme();
      loadSampleData();
    });
  </script>
  <script type="module" src="../src/geojson-editor.js"></script>
</body>
</html>
